### Spring AOP
<br>

#### 프록시와 내부 호출 - 문제
스프링은 프록시 방식의 AOP 사용<br>
따라서 AOP 적용위해 항상 프록시를 통해 대상 객체를 호출해야 한다.<br>
프록시를 거치지 않고 대상 객체를 호출하면 AOP 적용 X, 어드바이스 호출 X<br>

AOP 를 적용하면 스프링은 대상 객체 대신 프록시를 스프링 빈으로 등록함 <br>
따라서 스프링은 의존관계 주입시에 항상 프록시 객체를 주입함<br>
프록시 객체가 주입되기 때문에 대상 객체를 직접 호출하는 문제는 일반적으로 발생하지 않는다.<br>

하지만, 꼭 주의해야 할 점은, <br>
대상 객체의 내부에서 메소드 호출이 발생하면 프록시를 거치지 않고 대상 객체를 직접 호출하는 문제가 발생한다.<br>

 <br>

#### 프록시 기술과 한계 - CGLIB
스프링에서 CGLIB 는 구체 클래스를 상속받아 AOP 프록시를 생성할 때 사용한다. <br>

**CGLIB 구체 클래스 기반 프록시 문제점** <br>
* 대상 클래스에 기본 생성자 필수
* 생성자 2번 호출 문제
* final 키워드 클래스, 메소드 사용 불가
<br>

<br>

###### 대상 클래스에 기본 생성자 필수
CGLIB 는 구체 클래스를 상속받는다. <br>
java 에서 상속받으면 자식 클래스의 생성자를 호출할때 자식 클래스의 생성자에서 부모 클래스의 생성자도 호출해야한다.<br>

(참고)<br>
java 문법 규약상 자식클래스의 생성자 첫줄에 부모 클래스의 기본생성자를 호출하는 super() 를 생략할 수 있다.
<br>
CGLIB 를 사용할 때 CGLIB 가 만드는 프록시의 생성자는 우리가 호출하는 것이 아니다.<br>
CGLIB 프록시는 대상 클래스를 상속받고, 생성자에서 대상 클래스의 기본 생성자를 호출한다.<br>
따라서 대상 클래스에 기본 생성자를 만들어야 한다.<br>

###### 생성자 2번 호출 문제
CGLIB 는 구체 클래스를 상속받는다. <br>
java 에서 상속을 받으면 자식 클래스의 생성자를 호출할 때 부모 클래스의 생성자도 호출해야한다. <br>
1. 실제 target 의 객체를 생성할 때
2. 프록시 객체를 생성할 때 부모 클래스의 생성자 호출

###### final 키워드 클래스, 메소드 사용 불가
final 클래스는 상속 불가, final 메소드는 오버라이딩 불가 <br>
CGLIB 는 상속 기반으로 하기 때문에 프록시가 생성되지 않거나 동작하지 않는다.


