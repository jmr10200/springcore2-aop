### Spring AOP
<br>

#### 프록시와 내부 호출 - 문제
스프링은 프록시 방식의 AOP 사용<br>
따라서 AOP 적용위해 항상 프록시를 통해 대상 객체를 호출해야 한다.<br>
프록시를 거치지 않고 대상 객체를 호출하면 AOP 적용 X, 어드바이스 호출 X<br>

AOP 를 적용하면 스프링은 대상 객체 대신 프록시를 스프링 빈으로 등록함 <br>
따라서 스프링은 의존관계 주입시에 항상 프록시 객체를 주입함<br>
프록시 객체가 주입되기 때문에 대상 객체를 직접 호출하는 문제는 일반적으로 발생하지 않는다.<br>

하지만, 꼭 주의해야 할 점은, <br>
대상 객체의 내부에서 메소드 호출이 발생하면 프록시를 거치지 않고 대상 객체를 직접 호출하는 문제가 발생한다.<br>

 <br>

#### 프록시 기술과 한계 - CGLIB
스프링에서 CGLIB 는 구체 클래스를 상속받아 AOP 프록시를 생성할 때 사용한다. <br>

**CGLIB 구체 클래스 기반 프록시 문제점** <br>
* 대상 클래스에 기본 생성자 필수
* 생성자 2번 호출 문제
* final 키워드 클래스, 메소드 사용 불가
<br>

<br>

###### 대상 클래스에 기본 생성자 필수
CGLIB 는 구체 클래스를 상속받는다. <br>
java 에서 상속받으면 자식 클래스의 생성자를 호출할때 자식 클래스의 생성자에서 부모 클래스의 생성자도 호출해야한다.<br>

(참고)<br>
java 문법 규약상 자식클래스의 생성자 첫줄에 부모 클래스의 기본생성자를 호출하는 super() 를 생략할 수 있다.
<br>
CGLIB 를 사용할 때 CGLIB 가 만드는 프록시의 생성자는 우리가 호출하는 것이 아니다.<br>
CGLIB 프록시는 대상 클래스를 상속받고, 생성자에서 대상 클래스의 기본 생성자를 호출한다.<br>
따라서 대상 클래스에 기본 생성자를 만들어야 한다.<br>

###### 생성자 2번 호출 문제
CGLIB 는 구체 클래스를 상속받는다. <br>
java 에서 상속을 받으면 자식 클래스의 생성자를 호출할 때 부모 클래스의 생성자도 호출해야한다. <br>
1. 실제 target 의 객체를 생성할 때
2. 프록시 객체를 생성할 때 부모 클래스의 생성자 호출

###### final 키워드 클래스, 메소드 사용 불가
final 클래스는 상속 불가, final 메소드는 오버라이딩 불가 <br>
CGLIB 는 상속 기반으로 하기 때문에 프록시가 생성되지 않거나 동작하지 않는다.


#### 스프링의 해결책
* 스프링 3.2, CGLIB 를 스프링 내부에 함께 패키징 : spring-core org.springframework
* CGLIB 기본 생성자 필수 문제 해결 : 4.0 부터 objenesis 라이브러리 사용
* 생성자 2번 호출 문제 해결 : objenesis 라이브러리
* 스프링부트 2.0 - CGLIB 기본 사용 : 구체 클래스 타입 의존관계 주입문제 해결
-> 스프링 부트는 별도의 설정이 없다면 proxyTargetClass=true 로 설정하여 사용 <br>
-> 따라서 인터페이스가 있어도 JDK 가 아닌 항상 CGLIB 사용하여 구체클래스 기반 프록시 생성 <br>


##### 정리
스프링은 스프링 부트 2.0 에서 CGLIB 를 기본으로 사용하도록 결정 <br>
CGLIB 를 사용하면 JDK 에서 동작하지 않는 구체 클래스 주입이 가능하다. <br>
추가로 CGLIB 의 단점들도 많이 해결되었다.